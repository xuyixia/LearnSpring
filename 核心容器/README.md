
核心容器的功能是“控制反转、依赖注入（DI）”,通过DI和面向接口（依赖注入阶段）的组合，能够将依赖关系降到最低。

要使用DI，需要给出以下信息：
1. bean的信息 
2. 装配的信息

Spring给出了三种装配机制：
1. XML显示配置
2. Java显示配置（JavaConfig）
3. 隐式的bean发现机制和自动装配（自动化装配Bean）

# 各配置方式的实践
## 一、《S.A》作者极力推荐的自动化配置
不支持自动化的场景：
1. 装配第三方库中的组件，无法对它们进行注解；
2. Spring版本低于3；

对照上文中DI的使用要求，实现自动化配置的前提是开启了以下服务：
1. 组件扫描
2. 自动装配

自动化配置是基于注解来实现的，因此每个被容器管理的Bean都需要被注解。

### 自动化配置用到的注解之概述
1. @component 组件，可以理解为bean,默认ID为类名（首字母小写），其默认属性value指定一个ID。
2. @Configuration 用于标识JavaConfig类
3. @ConponentScan 用于JavaConfig类,代表开启组件扫描，默认扫描JavaConfig类同级目录及其子目录。其属性basepackages可以给定一个或多个基础包路径。在使用该注解时，会涉及到一个类型安全的问题，即如果指定String类型作为基础包路径，在重构的环境下容易出错。使用属性basePackageClasses指定一批类，然后以类的包为基础包。对于基础包类，最好的实践是以一个空的标记接口来实现，不涉及实际操作类，防止删除后出错。为什么要这么做，因为自动装配的信息是隐式的，改动信息的任何一部分会导致难以检查的错误。
4. @autowired 自动装配分为1.构造器装配2.setter方法装配（自动装配情况下，方法名随意，因为有注解）

由于Spring容器是面向接口的，所以被注解的Bean必须是接口的各个实现类。

为一些bean添加了@Component注解后，接下来要开启“组件扫描”服务。该服务必须被显示配置，因此不得不借助XML或JavaConfig的帮助。根据之前提到的装配机制优先级，这里我们选择“类配置”。创建一个Config类（最好以config为后缀）并用@XonponentScan和@Configuration注解它。

以上就是注册bean和开启组件扫描的全过程，现在将关注点移到bean内。Bean和Bean之间除了都是容器组件这一层关系外，还有相互依赖关系。自动化装配就是用来解决Bean之间依赖关系的。


### 处理自动装配的歧义性
首先我们统一一些概念上的认知：
1. 自动（隐式）配置对应自动装配；
2. 显示配置对应依赖注入；

在依赖注入（自动装配）阶段，显示配置可以做到指定某一个具体的类进行注入，这是没有歧义的。而自动装配受其实现原理的影响，装配对象（属性、方法参数、构造器参数）必须是唯一的，无歧义的，不然Spring无法确定装配哪一个。对于有歧义性的选择，spring会抛出异常。

为帮助理解这一概念，举个例子：小明让老师帮他买包烟，老师到了商店一看，几十种烟，买哪一种小明也没说。怕买错烟小明责怪，老师只能给小明爸爸打电话了。小明卒。

在实际项目中，一个设计良好的架构都是面向接口的，一般情况下都是一个接口对应一个实现类，因此歧义性的问题比较罕见，当然这也是一种避免歧义性的方法。

自动装配是Spring搞出来的，没理由只管生不管养的。没错，Spring不是负心汉，它给出了两个解决方案。

1. 设置首选（primary）bean （正确用法是相同类型中只能存在一个，当然也存在错误用法）
2. 限定符（qualifier）缩小选择范围 （比前者强大）

解决方案按照配置方式又分为三种，因此2x3=6

设置首选bean:
1. 在自动配置环境下，为bean添加一个注解@Primary
2. 在显示配置（基于java配置）环境下，在@bean注解的方法上添加@primary注解
3. 在显示配置（基于XML配置）环境下，在bean元素中添加primary属性，属性值为true

添加限定符：

在实际操作前要弄清以下关键点：
1. 弄清限定符和ID的关系。在未明确给出限定符的情况下，bean的ID即是它的限定符。
2. 弄清ID作为限定符会使两者耦合严重，一方有变即出错。因此不应以ID作为限定符。
3. 为解决上述问题，可以采取自定义限定符。

实践：
1. 在自动配置环境下，@Qualifier注解是搭配其它注解一起使用的。当和@component一起使用时，说明是为当前bean设置限定符；当和@autowired一起使用时，说明是引用限定符。
2. 在显示配置（基于java配置）环境下，在@bean注解后追加@Qualifier注解即是设置限定符，在注入方法上添加注解即是引用限定符。


问题再深入一点，限定符可以理解为一种标签，总会出现两个不同的类有同样限定符的情况。解决这个问题理论上只需再添加一个限定符即可。

打个比方，小明的同学叫小冥，他俩的名字拼音都是“xiaoming”。某一天老师拿来一封信，信的收件人写着“xiaoming”。老师也没法确定给谁，但是寄件人写的是“xiaoli”，老师就知道给小明了，因为小明的另一个身份是“xiaoli的男朋友”。

但是java规定一个类上不能同时存在一个以上的相同注解，因此重复使用@Qualifier添加限定符是不现实的。我们可以自定义限定符注解，该注解只需被@Qualifier注解即可成为限定符注解。用自定义注解去注解bean即可。（详细操作见《Spring Action 4th》）


## 二、基于Java配置类
作者说java类更强大，类型安全，对重构友好，是优于XML的。

### 注解一览
1. @Configuration 
2. @bean(target=method) 该注解应用于方法上，该方法创建一个对象并返回，注解会通知容器进行管理。属性name给定指定ID。




## 三、基于XML配置文件
可以使用Spring tools suite插件快捷生成XML文件模板

### 标签一览
1. \<beans\\>
2. \<bean>\<constructor-arg ref/>\</bean>  
3. \<bean c:cd-ref \\> (c:cd-ref是Spring 3.0中引入的C-命名空间和模式声明)


在编译XML配置文件时，最好的做法是在一个现有的XML配置模板上操作。可以选择到别的项目copy,也可以用插件生成。

所有的bean都需要配置到\<beans\>元素内，每一个bean元素需要给出全限定名，注意全限定名的分隔符是“.”,而类的路径名则是“/”。那些存在依赖关系的bean是需要配置ID的，独立的bean则无需这么做。虽然在解析XML时，未定义ID的bean会被补上默认的id，但是最好是自定义id。最后，需要知道的是XML中的bean,在初始化时是直接调用默认构造器的。因此，每个bean都需要给出默认构造器，从这一点来看，XML的约束较强。

配置完bean的信息，紧接着就是装配bean。装配bean的操作本质上是java类和对象的操作，为某个类创建实例，从外部初始化属性只能靠构造器和方法。

XML实现了构造器注入和setter方法注入（注意xml和java配置在方法注入中方法命名上的不同，前者必须是setter,后者只看注解）。

1. 构造器注入
    
    有两种配置方法：
        
        1. Spring3.0的新特性"c-命名空间和模式声明"
        2. <constructor-arg>

2. setter方法注入

依赖的对象大部分时候是其它的bean，但也有特殊的情况，比如依赖字面量、集合等。在基于java配置方式中，对依赖的装配比较灵活，因此无论是bean还是字面量等都不是问题，而在XML中，需要显示配置。（疑问：自动配置在这方面是如何运作的？）




## 四、配置方式的对比
在做笔记的时候就能深深的感受到三者的优劣。XML语义复杂，受到的约束较多，需要很细心才能配置正确。基于java配置相对前者在灵活度上有很大的优势，但该配的还是要配。此刻我才能理解作者的推荐，的确是自动配置最好。

显示配置也并不是一无是处，在维护bean的信息上，显示配置的好处是毋庸置疑的，因此，当开发和维护不是同一个人的情况下，最好在开发阶段用自动配置，后期换回显示配置。

下面部分总结下它们之间的优劣对比：

1. XML中的各元素的各属性值以字符串的形式给出，其无法在编译期的检查中受益，这一点Java配置类占有优势。需要补充的是，有的IDE弥补了XML在编译期的检查中的缺陷，所以对XML要有个本质上的认知。
2. 当应用环境出现变化，如更改了包结构、类名或大面积重构代码，对XML配置带来较大影响。这一点上那些能感知Spring功能的IDE也对XML的这一缺陷做出了改善。
3. 在对bean实例化的过程中，基于XML配置的bean只能被动地接受默认构造器来初始化，可见其灵活性有多差；相比基于java配置bean，后者并没有对bean的初始化做出太多干涉，原则上只要给出bean的实例引用即可。

````java

@Component("ak47")
public class Ak47 implement GunInterface{
    ...
}

````
无论怎么改类名，都不会影响bean的声明和依赖的注入。相反在xml中，一旦改了类名，对应的XML配置信息也要改。这就是类型安全？


## 五、配置方式的混用
在理想的条件下，在选择配置方式的时候，我们遵循“自动化配置优于java配置优于XML配置”的原则。事实上很多情况下无法选择单一配置方式，比如当Spring版本不支持注解、配置第三方库的bean等。因此实际操作中，配置方式的混用是不可避免的，实际上自动配置方式的实现就是建立在混用模式上的（开启扫描）。

混用模式中，装配用到的bean的来源是一个问题。

自动装配bean的时候，它会考虑容器中所有的bean，而不考虑bean是通过哪种方式被加载到容器。而在另两种方式里，它们不会去考虑整个容器中全部的bean,它们只考虑自己配置范围内的bean,因此如果存在依赖关系的两个bean不是配置在一个地方，那么就需要导入配置。

主要分为四种情况：
1. 基于java配置（主）和基于java配置（从）
2. 基于java配置（主）和XML（从）
3. XML（主）和XML（从）
4. XML（主）和基于java配置（从）

假设被依赖的bean所在的配置为从配置，相反则为主配置。

@import注解用在基于java配置（主）上，其默认的属性value值为基于java配置（从）。

@importResource注解用在基于java配置（主）上，其默认的属性value值为xml（从），格式为“classpath:uri”。

\<import\>元素用在XML（主）中，其属性resource为xml（从）的相对路径。

\<bean\>元素用于XML（主）中，其属性class对应了基于java配置的配置类，class属性值为配置类的全限定名。


最优的实践：
所有的bean先分好类，每一类对应一个配置文件（javaConfig或xml），然后将有关联的配置文件通过导入组合到一起。

在组合的过程中，最好是单独创建一个配置文件作为根配置文件，它内部不定义任何bean，只负责定义配置文件间的导入关系。开启扫描服务就配置在根配置中。

















maven的依赖传递性只是帮忙下载依赖的依赖，而不自动将它们引入到类路径中。



什么是集成测试